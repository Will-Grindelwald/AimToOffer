# 刷题经验

与在实际工作生活中设计算法不同，这里主要讲解找工作笔试面试中算法题的解决之道。

这种问题的特点是: 是可解的(非 NP or XX 问题)、我们要找到最优解(次优解都不行)、专注于时间/空间性能(要尽可能高效/占空间少)

首先，我把题目分为两类：简单题 & 难题。

## 简单题

简单题的特点：用不到高深的算法设计思想(贪心，动归，回溯，分支限界...)和已有的那些复杂算法(KMP...)，只需要

* 简单的设计一下数据结构
    * 表: 顺序表，链表，有序表，栈，队
    * 树: 二叉树，一般树，森林
    * 图: 邻接矩阵，邻接表
    * 集: 哈希表，并查集
    * 其他
* 根据题目设计具体算法(一般就是将人工解题的思路抽象成计算机算法)(可能会用到简单的思想：分治...)，然后处理一下特殊情况及边界条件
* 或者将问题抽象成数据结构的常用算法
    * 表: 插、删、排序、查找
    * 树: 前中后层次遍历、
    * 图: BFS、DFS、最小生成树、最短路径、拓扑排序、关键路径、最大流、最小割
    * 集: 哈希、并查集

## 难题

往往要用到下述算法思想

### 分治

问题具有特点: 大问题可以分解为小问题，且大问题的解是小问题的解的组合，且问题可以无限分解下去，知道小问题可以直接给出答案

PS: 与动态规划的区别: 一个大问题可以分解为若干小问题，且若干小问题不交，且通过 all 小问题的解可以得到大问题的解。

例如: 

### 贪心

只要问题满足次模性/边际效应递减时贪心法就是可用的，而当问题是具有最优子结构(局部最优解能决定全局最优解/当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质)的问题用贪心可以得到最优解。

关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

可惜的是，它需要证明后才能真正运用到题目的算法中。
一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。

PS1: 在刷题时，得不到最优解我们是拒绝的，而问题具有最优子结构时我们往往使用动态规划，所以贪心法用的较少。

PS2: 与刷题不同，在解决实际问题时，贪心是最有效的(远比动态规划的要求要低，应用范围要广)，在大多问题上(尤其是 NP 问题)可以(在有限时间内)得到满意解(即很可能不是最优解)

### 动态规划

### 回溯

### 分支限界

## 特殊题目

### 概率题

其实是数学题，写好计算公式，编程只是为了计算，不要想着用蒙特卡洛法(永远不会 AC)。
